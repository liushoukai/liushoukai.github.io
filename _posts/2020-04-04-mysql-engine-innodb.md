---
layout: post
title: MySQL 锁分析
categories: database
tags: mysql
---

## 乐观锁🔒

概念定义：系统认为数据的更新在大多数情况下是不会产生冲突的，只在数据库更新操作提交的时候才对数据作冲突检测。如果检测的结果出现了与预期数据不一致的情况，则返回失败信息。

实现方式：在数据库表增加一个版本号的字段`version`，每次更新一行记录都使得该行版本号加一，开始更新之前先获取version的值，更新提交的时候带上之前获取的version值与当前version值作比较，如果不相等则说明version值发生了变化则检测到了并发冲突，本次操作执行失败，如果相等则操作执行成功。

```sql
update table set columnA = 1, version = version + 1 where id = #{id} and version = #{oldVersion}
```

适用场景：数据库乐观锁比较适合并发量不高并且写操作不频繁的场景。

* 优点：优点比较明显，由于在检测数据冲突时并不依赖数据库本身的锁机制，不会影响请求的性能，当产生并发且并发量较小的时候只有少部分请求会失败；
* 缺点：当应用并发量高的时候，数据库锁都是作用于同一行数据记录上，大量的请求同时请求同一条记录的行锁，会对数据库产生很大的写压力。并且version值在频繁变化也会导致大量请求失败，影响系统的可用性；

## 悲观锁🔒

概念定义：对数据进行操作更新时，对操作持悲观保守的态度，认为产生数据冲突的可能性很大，需要先对请求的数据加锁再进行相关的操作。

实现方式：通过数据库锁机制实现，即对查询语句添加for update关键字。

```sql
select * from table where id = 1 for update
```

适用场景：

并发量较小、又需要独占读取结果并依赖读取的结果进行判断的业务场景比较适合使用悲观锁。

* 优点：每一次行数据的访问都是独占的，可以严格保证数据访问的安全性；
* 缺点：每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞，影响系统可用性；
