---
layout: post
title: MySQL 锁分析
categories: database
tags: mysql
---

## lock与latch

在数据库中，lock与latch都可以被称为“锁”。但是两者有着截然不同的含义，本章主要关注的是lock。

latch一般称为闩锁（轻量级的锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以分为mutex（互斥量）和rwlock（读写锁）。
其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。

lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。
此外，lock，正如在大多数数据库中一样，是有死锁机制的。

{:class="table table-striped table-bordered table-hover"}
| | lock | latch |
| :-: | :-: | :-: |
| 对象 | 事物 | 线程 |
| 保护 | 数据库内容 | 内存数据结构 |
| 持续时间 | 事务期间 | 临界资源 |
| 模式 | 行锁、表锁、意向锁 | 读写锁、互斥量 |
| 死锁 | waits-for graph、 time out 等机制处理死锁 | 无死锁检测机制，通过应用程序加锁的顺序(lock leveling)保证无死锁情况发生 |
| 存在于 | Lock Manager 的哈希表中 | 每个数据结构的对象中 |

## InnoDB存储引擎行级锁

InnoDB存储引擎实现了如下两种标准的行级锁：

◆ 共享锁（S Lock）：允许事务读一行数据。
◆ 排他锁（X Lock）：允许事务删除或更新一行数据。

需要特别注意的是，S和X锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况。

InnoDB存储引擎支持多粒度（granular）锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁（Intention Lock）。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度（fine granularity）上进行加锁，若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。例如图6-3，如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，在对记录r加X锁之前，已经有事务对表1进行了S表锁，那么表1上已存在S锁，之后事务需要对记录r在表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。

InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。
其支持两种意向锁：
1）意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁；
2）意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁；

事务由存储引擎层实现（Innodb）
通过Redo Log实现原子性和持久性
通过Undo Log实现一致性
通过DoubleWrite保障数据页可靠性
通过MVCC+锁实现隔离性

## InnoDB如何保障数据页刷盘可靠性？

关于IO的最小单位：

1. 数据库IO的最小单位是16K（MySQL默认，oracle是8K）
2. 文件系统IO的最小单位是4K（也有1K的）
3. 磁盘IO的最小单位是512字节

因此，存在IO写入导致page损坏的风险：

Innodb buffer pool中的页大小是16K，FS写的最小I/O单位是4K，需要4次物理写；
如果意外掉电：发生了两次I/O

二、double write：两次写

提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。

1. Double write解决了什么问题

一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了2K突然掉电，也就是说前2K数据是新的，后14K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页。
redo只能加上旧、校检完整的数据页恢复一个脏块，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。

2. 使用情景

当数据库正在从内存想磁盘写一个数据页是，数据库宕机，从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。

3、double write工作流程

doublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata1...N)中连续的128个页，即2个区(extent)，大小也是2M。

1、当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；
2、接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；
3、待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)

## Innodb存储结构

Innodb存储结构
表空间>段>区>页
最小存储单位是页
每个页16KB
64个连续的页组成区

## LOCK IN SHARE / FOR UPDATE

[https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html]

`LOCK IN SHARE`和`FOR UPDATE`都是读锁，用于确保没有其他事务可以更新或删除查询的相同行。两者之间的区别在于它们在读取数据时如何处理锁。

`LOCK IN SHARE`模式不会阻止另一个事务读取被锁定的同一行。

`FOR UPDATE`防止对同一行的其他锁读操作。
