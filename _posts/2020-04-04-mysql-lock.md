---
layout: post
title: MySQL 锁分析
categories: database
tags: mysql
---

事务由存储引擎层实现（Innodb）
通过Redo Log实现原子性和持久性
通过Undo Log实现一致性
通过DoubleWrite保障数据页可靠性
通过MVCC+锁实现隔离性

## InnoDB如何保障数据页刷盘可靠性？

关于IO的最小单位：

1. 数据库IO的最小单位是16K（MySQL默认，oracle是8K）
2. 文件系统IO的最小单位是4K（也有1K的）
3. 磁盘IO的最小单位是512字节

因此，存在IO写入导致page损坏的风险：

Innodb buffer pool中的页大小是16K，FS写的最小I/O单位是4K，需要4次物理写；
如果意外掉电：发生了两次I/O

二、doublewrite：两次写

提高innodb的可靠性，用来解决部分写失败(partial page write页断裂)。

1. Double write解决了什么问题

一个数据页的大小是16K，假设在把内存中的脏页写到数据库的时候，写了2K突然掉电，也就是说前2K数据是新的，后14K是旧的，那么磁盘数据库这个数据页就是不完整的，是一个坏掉的数据页。redo只能加上旧、校检完整的数据页恢复一个脏块，不能修复坏掉的数据页，所以这个数据就丢失了，可能会造成数据不一致，所以需要double write。

2. 使用情景

当数据库正在从内存想磁盘写一个数据页是，数据库宕机，从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。

3、double write工作流程

doublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间(ibdata1...N)中连续的128个页，即2个区(extent)，大小也是2M。

1、当一系列机制触发数据缓冲池中的脏页刷新时，并不直接写入磁盘数据文件中，而是先拷贝至内存中的doublewrite buffer中；
2、接着从两次写缓冲区分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB；
3、待第二步完成后，再将doublewrite buffer中的脏页数据写入实际的各个表空间文件(离散写)；(脏页数据固化后，即进行标记对应doublewrite数据可覆盖)


## Innodb存储结构

Innodb存储结构
表空间>段>区>页
最小存储单位是页
每个页16KB
64个连续的页组成区
